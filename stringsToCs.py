import os
import re
import sys
import copy
import json
from openpyxl import load_workbook

WORKING_DIR = os.path.dirname(os.path.realpath(__file__))

IN_FILE = os.path.join(WORKING_DIR, "Strings.xlsx")
OUT_FILE = os.path.join(WORKING_DIR, "TheOtherRoles", "Modules", "GeneratedTranslations.cs")

def generateCSharpCode(in_files):
    stringData = {}
    for filename in in_files:
        if not os.path.isfile(filename):
            continue
        
        wb = load_workbook(filename, read_only = True)
        
        for s in wb:
            rows = s.iter_rows(min_col = 1, min_row = 2, max_col = 17, max_row = None)
            headers = []
            for header in s[1]:
                if header.value:
                    headers.append(header.value)
            
            for row in rows:
                name = row[0].value
                
                if not name:
                    continue
                
                data = {}
                
                for i, string in enumerate(row[1:]):
                    if string.value:
                        # I hate excel why did I do this to myself
                        data[i] = string.value.replace("\r", "").replace("_x000D_", "").replace("\\n", "\n")
                
                if data:
                    stringData[name] = data
    
    # 生成C#代码
    csharp_code = generateCSharpFile(stringData)
    
    with open(OUT_FILE, "w", encoding="utf-8", newline="\n") as f:
        f.write(csharp_code)
    
    print(f"已生成C#代码文件: {OUT_FILE}")

def generateCSharpFile(stringData):
    """生成C#代码文件内容"""
    
    # 构建字典初始化代码
    dict_init_code = []
    for key, translations in stringData.items():
        # 转义字符串中的特殊字符
        escaped_key = escapeCSharpString(key)
        
        lang_dict_lines = []
        for lang_id, text in translations.items():
            escaped_text = escapeCSharpString(text)
            lang_dict_lines.append(f"                {{ {lang_id}, \"{escaped_text}\" }}")
        
        lang_dict_code = ",\n".join(lang_dict_lines)
        dict_init_code.append(f"            {{\n                \"{escaped_key}\",\n                new Dictionary<int, string>\n                {{\n{lang_dict_code}\n                }}\n            }}")
    
    dict_init_full = ",\n".join(dict_init_code)
    
    # 完整的C#文件内容
    csharp_content = f"""using System.Collections.Generic;

namespace TheOtherRoles.Modules;

// This file is automatically generated by stringsToCs.py, please do not manually modify it
public static class GeneratedTranslations
{{
    private static readonly Dictionary<string, Dictionary<int, string>> stringData = new Dictionary<string, Dictionary<int, string>>
    {{
{dict_init_full}
    }};

    public static string GetString(string key, string def = null)
    {{
        // 移除颜色标签和前后空白
        var keyClean = System.Text.RegularExpressions.Regex.Replace(key, "<.*?>", "");
        keyClean = System.Text.RegularExpressions.Regex.Replace(keyClean, \"^-\\\\s*\", \"\");
        keyClean = keyClean.Trim();

        def ??= key;
        if (!stringData.ContainsKey(keyClean))
            return def;

        var data = stringData[keyClean];
        var lang = (int)AmongUs.Data.DataManager.Settings.Language.CurrentLanguage;

        if (data.ContainsKey(lang))
            return key.Replace(keyClean, data[lang]);
        if (data.ContainsKey(ModTranslation.defaultLanguage)) 
            return key.Replace(keyClean, data[ModTranslation.defaultLanguage]);

        return key;
    }}
}}
"""
    return csharp_content

def escapeCSharpString(s):
    """转义C#字符串中的特殊字符"""
    if s is None:
        return ""
    
    # 转义双引号、反斜杠等特殊字符
    escaped = s.replace("\\", "\\\\")  # 先转义反斜杠
    escaped = escaped.replace("\"", "\\\"")
    escaped = escaped.replace("\n", "\\n")
    escaped = escaped.replace("\r", "\\r")
    escaped = escaped.replace("\t", "\\t")
    
    return escaped

if __name__ == "__main__":
    in_files = [
        os.path.join(WORKING_DIR, "Strings.xlsx"),
        #os.path.join(WORKING_DIR, "Strings-Dev.xlsx")
    ]
    
    generateCSharpCode(in_files)